name: Service Orchestration & Automation

on:
  schedule:
    - cron: '0 2 * * *'  # Daily at 2 AM UTC
    - cron: '0 */6 * * *'  # Every 6 hours
  workflow_dispatch:
    inputs:
      action:
        description: 'Orchestration action to perform'
        required: true
        type: choice
        options:
        - full-deployment
        - health-check
        - scale-services
        - backup-data
        - rotate-secrets
        - update-dependencies
        - security-scan
      target_environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
        - development
      services:
        description: 'Services to target (comma-separated or "all")'
        required: false
        default: 'all'
        type: string

env:
  ECOSYSTEM_VERSION: '1.0.0'
  NODE_ENV: ${{ github.event.inputs.target_environment || 'staging' }}

jobs:
  orchestration-setup:
    runs-on: ubuntu-latest
    outputs:
      action: ${{ steps.setup.outputs.action }}
      environment: ${{ steps.setup.outputs.environment }}
      services: ${{ steps.setup.outputs.services }}
      timestamp: ${{ steps.setup.outputs.timestamp }}
    steps:
    - name: Setup orchestration parameters
      id: setup
      run: |
        # Determine action based on trigger
        if [[ "${{ github.event_name }}" == "schedule" ]]; then
          if [[ "${{ github.event.schedule }}" == "0 2 * * *" ]]; then
            echo "action=full-deployment" >> $GITHUB_OUTPUT
          else
            echo "action=health-check" >> $GITHUB_OUTPUT
          fi
          echo "environment=staging" >> $GITHUB_OUTPUT
        else
          echo "action=${{ github.event.inputs.action }}" >> $GITHUB_OUTPUT
          echo "environment=${{ github.event.inputs.target_environment }}" >> $GITHUB_OUTPUT
        fi
        
        echo "services=${{ github.event.inputs.services || 'all' }}" >> $GITHUB_OUTPUT
        echo "timestamp=$(date -u +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT

  service-discovery:
    runs-on: ubuntu-latest
    needs: orchestration-setup
    outputs:
      active-services: ${{ steps.discover.outputs.active-services }}
      deployment-targets: ${{ steps.discover.outputs.deployment-targets }}
    steps:
    - uses: actions/checkout@v4
    
    - name: Discover services and targets
      id: discover
      run: |
        # Discover active services
        services=()
        if [[ -d "backend" ]]; then services+=("backend"); fi
        if [[ -d "frontend" ]]; then services+=("frontend"); fi
        if [[ -f "docker-compose.yml" ]]; then
          # Extract services from docker-compose
          additional_services=$(docker-compose config --services 2>/dev/null || echo "")
          for service in $additional_services; do
            if [[ ! " ${services[@]} " =~ " ${service} " ]]; then
              services+=("$service")
            fi
          done
        fi
        
        services_json=$(printf '%s\n' "${services[@]}" | jq -R . | jq -s .)
        echo "active-services=$services_json" >> $GITHUB_OUTPUT
        
        # Discover deployment targets
        targets=()
        if [[ -f "railway.json" ]]; then targets+=("railway"); fi
        if [[ -f "render.yaml" ]]; then targets+=("render"); fi
        if [[ -f "Dockerfile" ]]; then targets+=("docker"); fi
        if [[ -d ".github" ]]; then targets+=("github-pages"); fi
        
        targets_json=$(printf '%s\n' "${targets[@]}" | jq -R . | jq -s .)
        echo "deployment-targets=$targets_json" >> $GITHUB_OUTPUT

  health-monitoring:
    runs-on: ubuntu-latest
    needs: [orchestration-setup, service-discovery]
    if: contains(fromJSON('["health-check", "full-deployment"]'), needs.orchestration-setup.outputs.action)
    strategy:
      matrix:
        service: ${{ fromJSON(needs.service-discovery.outputs.active-services) }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Health check - ${{ matrix.service }}
      run: |
        echo "Performing health check for ${{ matrix.service }}..."
        
        # Service-specific health checks
        case "${{ matrix.service }}" in
          "backend")
            if [[ "${{ needs.orchestration-setup.outputs.environment }}" == "production" ]]; then
              endpoint="${{ secrets.PROD_BACKEND_URL }}/health"
            elif [[ "${{ needs.orchestration-setup.outputs.environment }}" == "staging" ]]; then
              endpoint="${{ secrets.STAGING_BACKEND_URL }}/health"
            else
              endpoint="http://localhost:8000/health"
            fi
            
            # Attempt health check with retry
            for i in {1..3}; do
              if curl -sf "$endpoint" --max-time 10; then
                echo "‚úÖ Backend health check passed"
                break
              else
                echo "‚ùå Backend health check failed (attempt $i/3)"
                if [[ $i -eq 3 ]]; then exit 1; fi
                sleep 30
              fi
            done
            ;;
            
          "frontend")
            if [[ "${{ needs.orchestration-setup.outputs.environment }}" == "production" ]]; then
              endpoint="${{ secrets.PROD_FRONTEND_URL }}"
            elif [[ "${{ needs.orchestration-setup.outputs.environment }}" == "staging" ]]; then
              endpoint="${{ secrets.STAGING_FRONTEND_URL }}"
            else
              endpoint="http://localhost:3000"
            fi
            
            for i in {1..3}; do
              if curl -sf "$endpoint" --max-time 10 | grep -q "title"; then
                echo "‚úÖ Frontend health check passed"
                break
              else
                echo "‚ùå Frontend health check failed (attempt $i/3)"
                if [[ $i -eq 3 ]]; then exit 1; fi
                sleep 30
              fi
            done
            ;;
            
          *)
            echo "‚ÑπÔ∏è No specific health check defined for ${{ matrix.service }}"
            ;;
        esac
    
    - name: Report health status
      if: always()
      run: |
        if [[ "${{ job.status }}" == "success" ]]; then
          echo "üìä Health Status: ${{ matrix.service }} - HEALTHY"
        else
          echo "üö® Health Status: ${{ matrix.service }} - UNHEALTHY"
          
          # Send alert notification
          curl -X POST "${{ secrets.SLACK_WEBHOOK }}" \
            -H 'Content-type: application/json' \
            --data '{
              "text": "üö® Health Check Failed",
              "attachments": [{
                "color": "danger",
                "fields": [
                  {"title": "Service", "value": "${{ matrix.service }}", "short": true},
                  {"title": "Environment", "value": "${{ needs.orchestration-setup.outputs.environment }}", "short": true},
                  {"title": "Timestamp", "value": "${{ needs.orchestration-setup.outputs.timestamp }}", "short": false}
                ]
              }]
            }'
        fi

  automated-scaling:
    runs-on: ubuntu-latest
    needs: [orchestration-setup, service-discovery, health-monitoring]
    if: contains(fromJSON('["scale-services", "full-deployment"]'), needs.orchestration-setup.outputs.action)
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Analyze resource usage
      run: |
        echo "Analyzing current resource usage..."
        
        # Check Railway metrics (if applicable)
        if [[ -f "railway.json" ]] && [[ -n "${{ secrets.RAILWAY_TOKEN }}" ]]; then
          echo "Checking Railway resource usage..."
          
          # Query Railway GraphQL API for metrics
          curl -X POST "https://backboard.railway.app/graphql/v2" \
            -H "Authorization: Bearer ${{ secrets.RAILWAY_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d '{
              "query": "query { me { projects { services { metrics { cpu memory } } } } }"
            }' > railway_metrics.json
          
          # Analyze metrics and determine scaling needs
          python3 << 'EOF'
import json
import os

try:
    with open('railway_metrics.json') as f:
        data = json.load(f)
    
    # Analyze CPU and memory usage
    needs_scaling = False
    for project in data.get('data', {}).get('me', {}).get('projects', []):
        for service in project.get('services', []):
            metrics = service.get('metrics', {})
            cpu = metrics.get('cpu', 0)
            memory = metrics.get('memory', 0)
            
            if cpu > 80 or memory > 85:  # Scale if usage > 80%
                needs_scaling = True
                print(f"Service requires scaling - CPU: {cpu}%, Memory: {memory}%")
    
    if needs_scaling:
        os.environ['SCALING_REQUIRED'] = 'true'
        print("üîÑ Scaling required based on resource analysis")
    else:
        print("‚úÖ Current resource usage within acceptable limits")
        
except Exception as e:
    print(f"‚ùå Error analyzing metrics: {e}")
EOF
        fi
    
    - name: Execute scaling operations
      if: env.SCALING_REQUIRED == 'true'
      run: |
        echo "Executing scaling operations..."
        
        # Railway scaling
        if [[ -n "${{ secrets.RAILWAY_TOKEN }}" ]]; then
          echo "Scaling Railway services..."
          # Add Railway scaling logic here
        fi
        
        # Render scaling
        if [[ -n "${{ secrets.RENDER_API_KEY }}" ]]; then
          echo "Scaling Render services..."
          # Add Render scaling logic here
        fi

  dependency-management:
    runs-on: ubuntu-latest
    needs: orchestration-setup
    if: contains(fromJSON('["update-dependencies", "full-deployment"]'), needs.orchestration-setup.outputs.action)
    
    steps:
    - uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Update Python dependencies
      if: hashFiles('**/requirements.txt') != ''
      run: |
        echo "Updating Python dependencies..."
        
        # Update backend dependencies
        if [[ -f "backend/requirements.txt" ]]; then
          cd backend
          pip install --upgrade pip
          pip-compile --upgrade requirements.in || true
          cd ..
        fi
    
    - name: Update Node.js dependencies
      if: hashFiles('**/package.json') != ''
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
    - run: |
        echo "Updating Node.js dependencies..."
        
        if [[ -f "frontend/package.json" ]]; then
          cd frontend
          npm update
          npm audit fix --audit-level moderate || true
          cd ..
        fi
    
    - name: Create dependency update PR
      if: success()
      run: |
        if [[ -n "$(git status --porcelain)" ]]; then
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          branch_name="auto/dependency-update-${{ needs.orchestration-setup.outputs.timestamp }}"
          git checkout -b "$branch_name"
          git add .
          git commit -m "chore: automated dependency updates - ${{ needs.orchestration-setup.outputs.timestamp }}"
          git push origin "$branch_name"
          
          # Create PR using GitHub CLI
          gh pr create \
            --title "üîÑ Automated Dependency Updates" \
            --body "Automated dependency updates generated by service orchestration workflow.\n\n- Updated Python packages\n- Updated Node.js packages\n- Resolved security vulnerabilities\n\n**Environment**: ${{ needs.orchestration-setup.outputs.environment }}\n**Timestamp**: ${{ needs.orchestration-setup.outputs.timestamp }}" \
            --label "dependencies,automation" \
            --base main
        else
          echo "No dependency updates required"
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  backup-operations:
    runs-on: ubuntu-latest
    needs: orchestration-setup
    if: contains(fromJSON('["backup-data", "full-deployment"]'), needs.orchestration-setup.outputs.action)
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Database backup
      run: |
        echo "Performing database backup..."
        
        # PostgreSQL backup
        if [[ -n "${{ secrets.DATABASE_URL }}" ]]; then
          echo "Creating PostgreSQL backup..."
          
          # Extract connection details from DATABASE_URL
          python3 << 'EOF'
import os
import urllib.parse
from datetime import datetime

database_url = os.environ.get('DATABASE_URL', '')
if database_url:
    parsed = urllib.parse.urlparse(database_url)
    
    backup_filename = f"backup-{datetime.now().strftime('%Y%m%d-%H%M%S')}.sql"
    
    # Set environment variables for pg_dump
    os.environ['PGPASSWORD'] = parsed.password or ''
    
    print(f"Creating backup: {backup_filename}")
    print(f"Host: {parsed.hostname}")
    print(f"Database: {parsed.path[1:]}")
    print(f"User: {parsed.username}")
EOF
        fi
    
    - name: Configuration backup
      run: |
        echo "Backing up configuration files..."
        
        # Create configuration backup
        backup_dir="config-backup-${{ needs.orchestration-setup.outputs.timestamp }}"
        mkdir -p "$backup_dir"
        
        # Backup important configuration files
        cp docker-compose*.yml "$backup_dir/" || true
        cp *.json "$backup_dir/" || true
        cp *.yaml "$backup_dir/" || true
        cp .github/workflows/*.yml "$backup_dir/" || true
        
        # Create archive
        tar -czf "$backup_dir.tar.gz" "$backup_dir"
        
        echo "Configuration backup created: $backup_dir.tar.gz"
    
    - name: Upload backups to storage
      run: |
        echo "Uploading backups to secure storage..."
        
        # Upload to AWS S3 if configured
        if [[ -n "${{ secrets.AWS_ACCESS_KEY_ID }}" ]]; then
          echo "Uploading to S3..."
          # Add S3 upload logic here
        fi
        
        # Upload to GitHub Releases as artifacts
        if [[ -f "config-backup-${{ needs.orchestration-setup.outputs.timestamp }}.tar.gz" ]]; then
          echo "Storing backup as GitHub artifact..."
        fi

  security-operations:
    runs-on: ubuntu-latest
    needs: orchestration-setup
    if: contains(fromJSON('["security-scan", "rotate-secrets", "full-deployment"]'), needs.orchestration-setup.outputs.action)
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Security vulnerability scan
      if: contains(fromJSON('["security-scan", "full-deployment"]'), needs.orchestration-setup.outputs.action)
      uses: securecodewarrior/github-action-add-sarif@v1
      with:
        sarif-file: 'security-scan.sarif'
    
    - name: Rotate secrets
      if: needs.orchestration-setup.outputs.action == 'rotate-secrets'
      run: |
        echo "Rotating ecosystem secrets..."
        
        # Generate new secrets
        python3 scripts/generate-secrets.py \
          --env "${{ needs.orchestration-setup.outputs.environment }}" \
          --output ".env.rotated" \
          --github-repo "${{ github.repository }}"
        
        echo "‚úÖ Secrets rotated successfully"
    
    - name: Security compliance check
      run: |
        echo "Performing security compliance checks..."
        
        # Check for exposed secrets in code
        echo "Scanning for exposed secrets..."
        
        # Check Docker security
        if [[ -f "Dockerfile" ]]; then
          echo "Analyzing Dockerfile security..."
          # Add Dockerfile security analysis
        fi
        
        # Check dependencies for vulnerabilities
        echo "Checking dependencies for known vulnerabilities..."
        
  notification-dispatch:
    runs-on: ubuntu-latest
    needs: [orchestration-setup, health-monitoring, automated-scaling, dependency-management, backup-operations, security-operations]
    if: always()
    
    steps:
    - name: Compile orchestration report
      run: |
        echo "Compiling orchestration report..."
        
        # Collect job statuses
        health_status="${{ needs.health-monitoring.result || 'skipped' }}"
        scaling_status="${{ needs.automated-scaling.result || 'skipped' }}"
        deps_status="${{ needs.dependency-management.result || 'skipped' }}"
        backup_status="${{ needs.backup-operations.result || 'skipped' }}"
        security_status="${{ needs.security-operations.result || 'skipped' }}"
        
        # Generate status emoji
        get_emoji() {
          case $1 in
            "success") echo "‚úÖ" ;;
            "failure") echo "‚ùå" ;;
            "cancelled") echo "üî∂" ;;
            "skipped") echo "‚è≠Ô∏è" ;;
            *) echo "‚ùì" ;;
          esac
        }
        
        # Create report
        cat << EOF > orchestration_report.md
# üéº Service Orchestration Report

**Action**: ${{ needs.orchestration-setup.outputs.action }}
**Environment**: ${{ needs.orchestration-setup.outputs.environment }}
**Timestamp**: ${{ needs.orchestration-setup.outputs.timestamp }}

## üìä Operation Results

| Operation | Status | Result |
|-----------|--------|--------|
| Health Monitoring | $(get_emoji "$health_status") | $health_status |
| Auto Scaling | $(get_emoji "$scaling_status") | $scaling_status |
| Dependencies | $(get_emoji "$deps_status") | $deps_status |
| Backup Operations | $(get_emoji "$backup_status") | $backup_status |
| Security Operations | $(get_emoji "$security_status") | $security_status |

## üîó Links
- [Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
- [Repository](https://github.com/${{ github.repository }})

EOF
        
        echo "Report generated:"
        cat orchestration_report.md
    
    - name: Send notifications
      if: always()
      run: |
        # Send Slack notification
        if [[ -n "${{ secrets.SLACK_WEBHOOK }}" ]]; then
          echo "Sending Slack notification..."
          
          # Determine overall status
          if [[ "${{ contains(needs.*.result, 'failure') }}" == "true" ]]; then
            status_color="danger"
            status_emoji="üö®"
            status_text="FAILED"
          elif [[ "${{ contains(needs.*.result, 'cancelled') }}" == "true" ]]; then
            status_color="warning"
            status_emoji="üî∂"
            status_text="CANCELLED"
          else
            status_color="good"
            status_emoji="‚úÖ"
            status_text="SUCCESS"
          fi
          
          curl -X POST "${{ secrets.SLACK_WEBHOOK }}" \
            -H 'Content-type: application/json' \
            --data-binary @- << EOF
{
  "text": "$status_emoji Service Orchestration Complete",
  "attachments": [{
    "color": "$status_color",
    "fields": [
      {"title": "Action", "value": "${{ needs.orchestration-setup.outputs.action }}", "short": true},
      {"title": "Environment", "value": "${{ needs.orchestration-setup.outputs.environment }}", "short": true},
      {"title": "Status", "value": "$status_text", "short": true},
      {"title": "Timestamp", "value": "${{ needs.orchestration-setup.outputs.timestamp }}", "short": true}
    ],
    "actions": [{
      "type": "button",
      "text": "View Details",
      "url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
    }]
  }]
}
EOF
        fi